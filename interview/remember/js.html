<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS 基础 | awesome-bookmarks</title>
    <meta name="description" content="个人收藏夹 beta">
    <link rel="icon" href="/awesome-bookmarks/favicon.ico">
    
    <link rel="preload" href="/awesome-bookmarks/assets/css/0.styles.d75f1eb4.css" as="style"><link rel="preload" href="/awesome-bookmarks/assets/js/app.6d21f2b1.js" as="script"><link rel="preload" href="/awesome-bookmarks/assets/js/2.d71abe12.js" as="script"><link rel="preload" href="/awesome-bookmarks/assets/js/63.934cac4a.js" as="script"><link rel="prefetch" href="/awesome-bookmarks/assets/js/10.38103395.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/11.382aad7a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/12.b09edcb5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/13.46d50fbb.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/14.fa523c1c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/15.40bdde08.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/16.16e13750.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/17.43c04973.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/18.874b276a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/19.b81f03fd.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/20.c3ce8b61.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/21.606a96b0.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/22.08cea50f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/23.ba75143a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/24.31b3b867.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/25.a97fbb61.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/26.4d0da639.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/27.f645bc10.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/28.152f56ae.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/29.b579aca3.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/3.9f000209.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/30.5ccca720.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/31.342f35f9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/32.d153e2ca.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/33.f61a4a6e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/34.b7970d3a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/35.2acdba1f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/36.0f049f33.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/37.dc0de5cb.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/38.aa68d0b5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/39.bc9a0a7b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/4.f5d8a40b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/40.33dd4a49.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/41.ec83f898.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/42.06b54f27.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/43.0b9e3c98.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/44.8572cd94.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/45.e8c7fbf4.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/46.e74c467f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/47.f9bb5db0.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/48.5f05c3df.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/49.2677cd3c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/5.38d8cf1c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/50.b29e2174.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/51.ae7ce038.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/52.267d0ea5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/53.727a78d2.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/54.306cefff.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/55.93971dbd.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/56.88870c2f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/57.8f2e1c8e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/58.1ee26eda.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/59.950a8d0d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/6.70764b71.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/60.7133416e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/61.4a019ca7.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/62.82f86150.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/64.8c7489da.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/65.30156cb7.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/66.98874a12.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/67.b9a70814.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/68.e5e58943.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/69.c9987b1c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/7.9c26ee20.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/70.d4a295f4.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/8.9e9d291f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/9.871d840b.js">
    <link rel="stylesheet" href="/awesome-bookmarks/assets/css/0.styles.d75f1eb4.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/awesome-bookmarks/" class="home-link router-link-active"><!----> <span class="site-name">awesome-bookmarks</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/awesome-bookmarks/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/awesome-bookmarks/interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/awesome-bookmarks/blog/" class="nav-link">Blog</a></div> <a href="https://github.com/xieliuduo" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/awesome-bookmarks/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/awesome-bookmarks/interview/" class="nav-link router-link-active">面试</a></div><div class="nav-item"><a href="/awesome-bookmarks/blog/" class="nav-link">Blog</a></div> <a href="https://github.com/xieliuduo" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>面试</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/awesome-bookmarks/interview/" class="sidebar-link">面试</a></li><li><a href="/awesome-bookmarks/interview/algorithms.html" class="sidebar-link">算法</a></li><li><a href="/awesome-bookmarks/interview/design-patterns.html" class="sidebar-link">设计模式</a></li><li><a href="/awesome-bookmarks/interview/js.html" class="sidebar-link">常规面试题</a></li><li><a href="/awesome-bookmarks/interview/network.html" class="sidebar-link">网络</a></li><li><a href="/awesome-bookmarks/interview/questions.html" class="sidebar-link">常规面试题</a></li><li><a href="/awesome-bookmarks/interview/react.html" class="sidebar-link">React</a></li><li><a href="/awesome-bookmarks/interview/vue.html" class="sidebar-link">Vue</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js-基础"><a href="#js-基础" aria-hidden="true" class="header-anchor">#</a> JS 基础</h2> <h3 id="mouseenter-与-mouseover-区别"><a href="#mouseenter-与-mouseover-区别" aria-hidden="true" class="header-anchor">#</a> mouseenter 与 mouseover 区别</h3> <p>mouseenter 和 mouseleave 只有是 target element 的时候才会触发。 mouseover 和 mouseleave 会冒泡， 子元素也会触发。</p> <h3 id="e-target-与-e-currenttarget"><a href="#e-target-与-e-currenttarget" aria-hidden="true" class="header-anchor">#</a> e.target 与 e.currentTarget</h3> <p>e.target 指向触发事件监听的对象。</p> <p>e.currentTarget 指向添加监听事件的对象。</p> <h3 id="isnan-vs-number-isnan"><a href="#isnan-vs-number-isnan" aria-hidden="true" class="header-anchor">#</a> isNaN vs Number.isNaN</h3> <p>Number.isNaN() 方法确定传递的值是否为 NaN 和其类型是 Number。它是原始的全局 isNaN()的更强大的版本。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
Number<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token comment">//true</span>
</code></pre></div><h3 id="number-issafeinteger"><a href="#number-issafeinteger" aria-hidden="true" class="header-anchor">#</a> Number.isSafeInteger()</h3> <p>用来判断传入的参数值是否是一个“安全整数”（safe integer）。一个安全整数是一个符合下面条件的整数</p> <p>安全整数范围为 -(253 - 1)到 253 - 1 之间的整数</p> <h3 id="tostring-valueof"><a href="#tostring-valueof" aria-hidden="true" class="header-anchor">#</a> toString valueOf</h3> <h3 id="addeventlistener"><a href="#addeventlistener" aria-hidden="true" class="header-anchor">#</a> addEventListener</h3> <ul><li>内存泄漏问题，只有保持静态函数引用才能被 <code>removeEventListener</code> 移除。</li> <li>passive: 提升页面滑动的流畅度</li> <li>useCapture: 事件捕获阶段触发 handler</li> <li>once: 只触发一次</li></ul> <h3 id="哪些事件不会事件冒泡"><a href="#哪些事件不会事件冒泡" aria-hidden="true" class="header-anchor">#</a> 哪些事件不会事件冒泡</h3> <ul><li>UI 事件
<ul><li>load</li> <li>unload</li> <li>scroll</li> <li>resize</li></ul></li> <li>焦点事件
<ul><li>blur</li> <li>focus</li></ul></li> <li>鼠标事件
<ul><li>mouseleave</li> <li>mouseenter</li></ul></li></ul> <h3 id="dispatchevent"><a href="#dispatchevent" aria-hidden="true" class="header-anchor">#</a> dispatchEvent</h3> <p>通过 dispatchEvent <code>new CustomEvent('myEvent', {detail:123});</code> 来触发自定义事件</p> <p>注意 new Event('build') vs new CustomEvent('build')</p> <h3 id="jsonp-原理"><a href="#jsonp-原理" aria-hidden="true" class="header-anchor">#</a> JSONP 原理</h3> <ul><li>在使用 JSONP 的时候必须要保证使用的 JSONP 服务必须是安全可信的。会有安全问题</li> <li>JSONP 在调用失败的时候不会返回各种 HTTP 状态码</li> <li>JSONP 只支持 GET 请求而不支持 POST 等其它类型的 HTTP 请求。</li></ul> <h3 id="_7-中类型"><a href="#_7-中类型" aria-hidden="true" class="header-anchor">#</a> 7 中类型</h3> <p>Number 、Null、Undefined、String、 Boolean 、Object 、Symbol</p> <h3 id="原生对象"><a href="#原生对象" aria-hidden="true" class="header-anchor">#</a> 原生对象</h3> <p><img src="https://wpimg.wallstcn.com/5c2fdb22-51ca-4206-918d-042ad5dbee1f.png" alt=""></p> <h3 id="null-vs-undefined"><a href="#null-vs-undefined" aria-hidden="true" class="header-anchor">#</a> null vs undefined</h3> <ul><li><p>null 表示&quot;没有对象&quot;，即该处不应该有值
（1） 作为函数的参数，表示该函数的参数不是对象。
（2） 作为对象原型链的终点。</p></li> <li><p>undefined 表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。
（1）变量被声明了，但没有赋值时，就等于 undefined。
（2) 调用函数时，应该提供的参数没有提供，该参数等于 undefined。
（3）对象没有赋值的属性，该属性的值为 undefined。
（4）函数没有返回值时，默认返回 undefined。</p></li></ul> <h3 id="为什么用-void-0-代替-undefined"><a href="#为什么用-void-0-代替-undefined" aria-hidden="true" class="header-anchor">#</a> 为什么用 void 0 代替 undefined</h3> <p>答案很简单，undefined 并不是保留词（reserved word），它只是全局对象的一个属性，在低版本 IE 中能被重写。
undefined 在 ES5 中已经是全局对象的一个只读（read-only）属性了，它不能被重写。但是在局部作用域中，还是可以被重写的。
那么，ES5 大环境下，void 0 就没有用武之地了吗？答案是否定的，用 void 0 代替 undefined 能节省不少字节的大小，事实上，不少 JavaScript 压缩工具在压缩过程中，正是将 undefined 用 void 0 代替掉了。不少基础库如 underscore、vue 都是用 void 0 的</p> <h3 id="charcodeat-vs-codepointat"><a href="#charcodeat-vs-codepointat" aria-hidden="true" class="header-anchor">#</a> charCodeAt vs codePointAt</h3> <p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xFFFF 的字符），JavaScript 会认为它们是两个字符。ES6 提供了 codePointAt()方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">'𠮷a'</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// 134071</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 57271</span>

s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 97</span>
</code></pre></div><h3 id="精度问题"><a href="#精度问题" aria-hidden="true" class="header-anchor">#</a> 精度问题</h3> <p>es6 解决方案：</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">-</span> <span class="token number">0.3</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> Number<span class="token punctuation">.</span><span class="token constant">EPSILON</span><span class="token punctuation">)</span>
</code></pre></div><p>IEEE 754
使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有 float 32 位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。</p> <p>这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。</p> <p>64 位比特又可分为三个部分：</p> <p>符号位 S：第 1 位是正负数符号位（sign），0 代表正数，1 代表负数
指数位 E：中间的 11 位存储指数（exponent），用来表示次方数
尾数位 M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零</p> <h3 id="object-create-vs-new-function"><a href="#object-create-vs-new-function" aria-hidden="true" class="header-anchor">#</a> Object.create vs new Function</h3> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function-variable function">create</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">F</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 隐式构造函数</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 返回一个new</span>
<span class="token punctuation">}</span>
</code></pre></div><p>延伸： Object.create(null) vs {}</p> <p>https://panjiachen.github.io/awesome-bookmarks/blog/js.html#object-create-null-vs</p> <h3 id="普通函数-构造函数-箭头函数"><a href="#普通函数-构造函数-箭头函数" aria-hidden="true" class="header-anchor">#</a> 普通函数 构造函数 箭头函数</h3> <p>构造函数：</p> <ol><li>构造函数使用 new 关键字调用；普通函数不用 new 关键字调用；</li> <li>构造函数内部可以使用 this 关键字；普通函数内部不建议使用 this，因为这时候 this 指向的是 window 全局对象，这样无意间就会为 window 添加了一些全局变量或函数</li> <li>构造函数默认不用 return 返回值；普通函数一般都有 return 返回值</li> <li>构造函数首字母一般大写</li></ol> <p>箭头函数：</p> <ol><li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li> <li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li> <li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li> <li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</li></ol> <p>箭头函数不适用场景：</p> <ul><li>定义字面量方法</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> calculator <span class="token operator">=</span> <span class="token punctuation">{</span>
  array<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token function-variable function">sum</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>array<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">result<span class="token punctuation">,</span> item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> result <span class="token operator">+</span> item<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> window<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
<span class="token comment">// Throws &quot;TypeError: Cannot read property 'reduce' of undefined&quot;</span>
calculator<span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><ul><li><p>定义原型方法
如上同理</p></li> <li><p>是需要动态 this 的时候，也不应使用箭头函数。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> button <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'myButton'</span><span class="token punctuation">)</span>
button<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> button<span class="token punctuation">)</span> <span class="token comment">// =&gt; true</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token string">'Clicked button'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>上面代码运行时，点击按钮会报错，因为 button 的监听函数是一个箭头函数，导致里面的 this 就是全局对象。如果改成普通函数，this 就会动态指向被点击的按钮对象。</p> <h3 id="类型判断"><a href="#类型判断" aria-hidden="true" class="header-anchor">#</a> 类型判断</h3> <h3 id="字符串有最大长度吗"><a href="#字符串有最大长度吗" aria-hidden="true" class="header-anchor">#</a> 字符串有最大长度吗</h3> <p>JS 字符串的长度受到下标限制。理论最大长度是 2^53-1（即 js 中可表达的最大安全整数）。</p> <h3 id="promise"><a href="#promise" aria-hidden="true" class="header-anchor">#</a> promise</h3> <h4 id="promise-resolve-一定是走-success-的么？"><a href="#promise-resolve-一定是走-success-的么？" aria-hidden="true" class="header-anchor">#</a> promise.resolve 一定是走 success 的么？</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
p2<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">result</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'result'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">error</span> <span class="token operator">=&gt;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error <span class="token operator">+</span> <span class="token string">'---error'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span>
</code></pre></div><h4 id="catch-的两种写法"><a href="#catch-的两种写法" aria-hidden="true" class="header-anchor">#</a> catch 的两种写法</h4> <p>Promise.prototype.catch 方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <h4 id="reject"><a href="#reject" aria-hidden="true" class="header-anchor">#</a> reject</h4> <p>reject 方法的作用，等同于抛出错误。
如果 Promise 状态已经变成 resolved，再抛出错误是无效的。
因为 Promise 的状态一旦改变，就永久保持该状态，不会再变了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ok'</span><span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span> <span class="token comment">// 但还是会执行</span>
  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// ok</span>
</code></pre></div><h4 id="allsettled-any"><a href="#allsettled-any" aria-hidden="true" class="header-anchor">#</a> allSettled,any</h4> <h4 id="generator"><a href="#generator" aria-hidden="true" class="header-anchor">#</a> generator</h4> <p>实现一个状态机</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">clock</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tick!'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tock!'</span><span class="token punctuation">)</span>
    <span class="token keyword">yield</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="协程与子例程的差异"><a href="#协程与子例程的差异" aria-hidden="true" class="header-anchor">#</a> 协程与子例程的差异</h4> <p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。
协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p> <p>传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p> <p>http://es6.ruanyifeng.com/#docs/generator#Generator-%E4%B8%8E%E5%8D%8F%E7%A8%8B</p> <h3 id="宏观任务-微观任务"><a href="#宏观任务-微观任务" aria-hidden="true" class="header-anchor">#</a> 宏观任务 微观任务</h3> <p>由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p> <p>macro-task 包括：script(整体代码,主进程), setTimeout, setInterval, setImmediate, I/O, UI rendering, requestAnimationFrame。
micro-task 包括：process.nextTick, Promise 回调, Object.observe(已废弃), MutationObserver(DOM 变化监听器)</p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script start'</span><span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise1'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'promise2'</span><span class="token punctuation">)</span>
    <span class="token keyword">var</span> begin <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> begin <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'apple'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'script end'</span><span class="token punctuation">)</span>
</code></pre></div><p>process.nextTick &gt; Promise.then &gt; MutationObserver</p> <p>延伸： vue 的 nextTick 是什么</p> <p>https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/
https://juejin.im/post/59e85eebf265da430d571f89
https://juejin.im/post/5b35cdfa51882574c020d685</p> <h3 id="settimeout-setinterval-setimmediate-process-nexttick"><a href="#settimeout-setinterval-setimmediate-process-nexttick" aria-hidden="true" class="header-anchor">#</a> setTimeout setInterval setImmediate process.nextTick</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// test.js</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
process<span class="token punctuation">.</span><span class="token function">nextTick</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>http://www.ruanyifeng.com/blog/2018/02/node-event-loop.html</p> <p>注意</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">setImmediate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>他们两者的执行顺序是不确定的
https://imweb.io/topic/5b148768d4c96b9b1b4c4ea1</p> <h3 id="settimeout-setinterval"><a href="#settimeout-setinterval" aria-hidden="true" class="header-anchor">#</a> setTimeout setInterval</h3> <p>对于 setInterval(fn,ms)来说，我们已经知道不是每过 ms 秒会执行一次 fn，而是每过 ms 秒，会有 fn 进入 Event Queue。
一旦 setInterval 的回调函数 fn 执行时间超过了延迟时间 ms，那么就完全看不出来有时间间隔了</p> <h3 id="event-loop"><a href="#event-loop" aria-hidden="true" class="header-anchor">#</a> event loop</h3> <p>timers
I/O callbacks
idle, prepare
poll
check
close callbacks</p> <h3 id="浏览器和-node-事件循环的区别"><a href="#浏览器和-node-事件循环的区别" aria-hidden="true" class="header-anchor">#</a> 浏览器和 Node 事件循环的区别</h3> <p>ibev 只能在 Unix 环境下运行。Windows 平台上与 kqueue(FreeBSD)或者(e)poll(Linux)等内核事件通知相应的机制是 IOCP。
libuv 提供了一个跨平台的抽象，由平台决定使用 libev 或 IOCP。</p> <p>们所看到的 node.js 单线程只是一个 js 主线程，本质上的异步操作还是由线程池完成的，node 将所有的阻塞操作都交给了内部的线程池去实现，本身只负责不断的往返调度，并没有进行真正的 I/O 操作，从而实现异步非阻塞 I/O，这便是 node 单线程和事件驱动的精髓之处了。</p> <h3 id="promise-原理"><a href="#promise-原理" aria-hidden="true" class="header-anchor">#</a> promise 原理</h3> <h3 id="async-await"><a href="#async-await" aria-hidden="true" class="header-anchor">#</a> async await</h3> <h2 id="webpack"><a href="#webpack" aria-hidden="true" class="header-anchor">#</a> webpack</h2> <h3 id="tree-shaking"><a href="#tree-shaking" aria-hidden="true" class="header-anchor">#</a> tree-shaking</h3> <h3 id="typeof"><a href="#typeof" aria-hidden="true" class="header-anchor">#</a> typeOf</h3> <p><a href="https://github.com/lifesinger/blog/issues/175" target="_blank" rel="noopener noreferrer">玉伯的分析<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p><code>Object.prototype.toString.call(obj)</code></p> <p>instanceof 在 iframe 中会有问题。因为多个窗口意味着多个全局环境，不同的全局环境拥有不同的全局对象，从而拥有不同的内置类型构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">''</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">//false</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span> <span class="token comment">//true</span>
<span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment">//true</span>
</code></pre></div><p>Object.prototype.toString 的原理是：
在 toString 方法被调用时,会执行下面的操作步骤:
获取 this 对象的[[Class]]属性的值，es6 中已调整为 <code>NativeBrand</code>
由于是获取 this 的属性，所以必须要使用 call 或者 apply。</p> <h3 id="object-defineproperty"><a href="#object-defineproperty" aria-hidden="true" class="header-anchor">#</a> Object.defineProperty</h3> <p>value, writable,enumerable,configurable</p> <h3 id="proxy"><a href="#proxy" aria-hidden="true" class="header-anchor">#</a> proxy</h3> <p>双向绑定一般有如下几种方法：</p> <ul><li>发布-订阅 KnockoutJS</li> <li>脏检查 Angular</li> <li>Object.defineProperty Vue2.x</li> <li>proxy Vue3.x</li></ul> <p>Proxy 是 Object.defineProperty 的全方位加强版，可以直接监听对象而非属性，Proxy 可以直接监听数组的变化。
<a href="https://juejin.im/post/5acd0c8a6fb9a028da7cdfaf" target="_blank" rel="noopener noreferrer">实现双向绑定 Proxy 比 defineProperty 优劣如何<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h3 id="尾调用"><a href="#尾调用" aria-hidden="true" class="header-anchor">#</a> 尾调用</h3> <h3 id="new-做了些什么"><a href="#new-做了些什么" aria-hidden="true" class="header-anchor">#</a> new 做了些什么</h3> <p>四大步骤：</p> <p>1、创建一个空对象，并且 this 变量引用该对象，// lat target = {};</p> <p>2、继承了函数的原型。// target.proto = func.prototype;</p> <p>3、属性和方法被加入到 this 引用的对象中。并执行了该函数 func// func.call(target);</p> <p>4、新创建的对象由 this 所引用，并且最后隐式的返回 this 。// 如果 func.call(target)返回的 res 是个对象或者 function 就返回它</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token keyword">new</span><span class="token punctuation">(</span><span class="token parameter">func</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	lat target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
	target<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> func<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>
	<span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">func</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;object&quot;</span> <span class="token operator">||</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">&quot;function&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
		<span class="token keyword">return</span> res<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	<span class="token keyword">return</span> target<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="mvc-mvp-mvvm"><a href="#mvc-mvp-mvvm" aria-hidden="true" class="header-anchor">#</a> MVC MVP MVVM</h3> <ul><li>MVC: Controller 作为 View 层和 Model 层之间的连接点，连接 View -&gt; Model 之间的通信，Model 层的数据更新后会通知 View 层的视图更新并反馈给用户。View 和 Model 之间的强耦合度会加大调试时的难度。</li> <li>MVP: Presenter 承接起了 View 和 Model 之间的双向通信，View 与 Model 不发生联系，降低了耦合度且方便单元测试。</li> <li>MVVM: ViewModel 中构建了一组状态数据，作为 View 状态的抽象，通过双向数据绑定使 ViewModel 中的状态数据与 View 的显示状态保持一致，这样 View 的显示状态变化会自动更新 ViewModel 的状态数据，ViewModel 状态数据的变化也会自动同步 View 的显示状态。</li></ul> <h3 id="前端模块"><a href="#前端模块" aria-hidden="true" class="header-anchor">#</a> 前端模块</h3> <h3 id="fetch-优缺点"><a href="#fetch-优缺点" aria-hidden="true" class="header-anchor">#</a> fetch 优缺点</h3> <ul><li>符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里
更好更方便的写法</li> <li>更加底层，提供的 API 丰富（request, response）</li> <li>脱离了 XHR，是 ES 规范里新的实现方式</li> <li>fetchtch 只对网络请求报错，对 400，500 都当做成功的请求，需要封装去处理</li> <li>fetch 默认不会带 cookie，需要添加配置项</li> <li>fetch 不支持 abort，不支持超时控制，使用 setTimeout 及 Promise.reject 的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费</li> <li>fetch 没有办法原生监测请求的进度，而 XHR 可以。</li></ul> <h3 id="xmlhttprequest"><a href="#xmlhttprequest" aria-hidden="true" class="header-anchor">#</a> XMLHttpRequest</h3> <p><code>xhrReq.open(method, url, async, user, password)</code></p> <p><code>readyState</code>:</p> <ul><li>0 UNSENT 代理被创建，但尚未调用 open() 方法。</li> <li>1 OPENED open() 方法已经被调用。</li> <li>2 HEADERS_RECEIVED send() 方法已经被调用，并且头部和状态已经可获得。</li> <li>3 LOADING 下载中； responseText 属性已经包含部分数据。</li> <li>4 DONE 下载操作已完成。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">===</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> xhr<span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="实现一个-bind"><a href="#实现一个-bind" aria-hidden="true" class="header-anchor">#</a> 实现一个 bind</h3> <h3 id="fragment"><a href="#fragment" aria-hidden="true" class="header-anchor">#</a> fragment</h3> <p><code>let fragment = document.createDocumentFragment();</code></p> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <h3 id="尾调用-2"><a href="#尾调用-2" aria-hidden="true" class="header-anchor">#</a> 尾调用</h3> <h3 id="weakmap-作用"><a href="#weakmap-作用" aria-hidden="true" class="header-anchor">#</a> WeakMap 作用</h3> <h3 id="for-in，object-keys-object-getownpropertynames-的区别"><a href="#for-in，object-keys-object-getownpropertynames-的区别" aria-hidden="true" class="header-anchor">#</a> for...in，Object.keys Object.getOwnPropertyNames 的区别</h3> <p>Object.getOwnPropertyNames(a) returns all own properties of the object a.
Object.keys(a) returns all enumerable own properties.
It means that if you define your object properties without making some of them enumerable: false these two methods will give you the same result.</p> <h3 id="css-in-js"><a href="#css-in-js" aria-hidden="true" class="header-anchor">#</a> css in js</h3> <h3 id="css-module"><a href="#css-module" aria-hidden="true" class="header-anchor">#</a> css module</h3> <h3 id="cookie-session"><a href="#cookie-session" aria-hidden="true" class="header-anchor">#</a> cookie session</h3> <p>cookie 不设置时间就是当浏览器全部关闭时失效
而 sessionStorage 是当 tab 关闭时就失效，tab 之间不共享。
有特殊例子：如通过 a 页面链接(或者用了 window.open)点开了 b 页面，它们之间是共享的。</p> <h3 id="es6-模块与-commonjs-模块的差异"><a href="#es6-模块与-commonjs-模块的差异" aria-hidden="true" class="header-anchor">#</a> ES6 模块与 CommonJS 模块的差异</h3> <ul><li>CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li> <li>CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li> <li>CommonJS 模块的顶层 this 指向当前模块。ES6 模块之中，顶层的 this 指向 undefined，这是两者的一个重大差异。</li></ul> <p>第二个差异是因为 CommonJS 加载的是一个对象（即 module.exports 属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p> <h3 id="循环依赖加载加载问题"><a href="#循环依赖加载加载问题" aria-hidden="true" class="header-anchor">#</a> 循环依赖加载加载问题</h3> <p>CommonJS 的一个模块，就是一个脚本文件。require 命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token string">'...'</span><span class="token punctuation">,</span>
  exports<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  loaded<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面代码就是 Node 内部加载模块后生成的一个对象。该对象的 id 属性是模块名，exports 属性是模块输出的各个接口，loaded 属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。</p> <p>以后需要用到这个模块的时候，就会到 exports 属性上面取值。即使再次执行 require 命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。</p> <p>es6</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//foo.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is running'</span><span class="token punctuation">)</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./bar'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar = %j'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar = %j after 500 ms'</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'foo is finished'</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//bar.js</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is running'</span><span class="token punctuation">)</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token boolean">false</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span>bar <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'bar is finished'</span><span class="token punctuation">)</span>
</code></pre></div><p>结果：
bar is running
bar is finished
foo is running
bar = false
foo is finished
bar = true after 500 ms</p> <p>https://zhuanlan.zhihu.com/p/33049803</p> <h3 id="amd-cmd"><a href="#amd-cmd" aria-hidden="true" class="header-anchor">#</a> AMD CMD</h3> <ul><li>AMD 推崇依赖前置、提前执行</li> <li>CMD 推崇依赖就近、延迟执行</li></ul> <h3 id="module-exports-和-exports-区别"><a href="#module-exports-和-exports-区别" aria-hidden="true" class="header-anchor">#</a> module.exports 和 exports 区别</h3> <p>exports 就是 module.exports 的别名，是用来简化书写的</p> <h3 id="async-与-generator-区别"><a href="#async-与-generator-区别" aria-hidden="true" class="header-anchor">#</a> async 与 Generator 区别</h3> <ol><li><p>内置执行器。 Generator 函数的执行必须靠执行器，所以才有了 co 函数库，而 async 函数自带执行器。
也就是说，async 函数的执行，与普通函数一模一样，只要一行。</p></li> <li><p>更好的语义。 async 和 await，比起星号和 yield，语义更清楚了。async 表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</p></li> <li><p>更广的适用性。 co 函数库约定，yield 命令后面只能是 Thunk 函数或 Promise 对象，
而 async 函数的 await 命令后面，可以跟 Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</p></li></ol> <h3 id="stopimmediatepropagation-vs-stoppropagation"><a href="#stopimmediatepropagation-vs-stoppropagation" aria-hidden="true" class="header-anchor">#</a> stopImmediatePropagation vs stopPropagation</h3> <p>stopPropagation()方法阻止事件对象移到到另一个节点上，但是允许当前节点的其他事件监听函数执行，而 stopImmediatePropagation()方法不仅阻止事件从当前节点移动到另一个节点上，它还不允许当前节点的其他事件监听函数执行。</p> <h3 id="serviceworker"><a href="#serviceworker" aria-hidden="true" class="header-anchor">#</a> serviceWorker</h3> <h3 id="重绘（repaint）和回流（reflow）"><a href="#重绘（repaint）和回流（reflow）" aria-hidden="true" class="header-anchor">#</a> 重绘（Repaint）和回流（Reflow）</h3> <h2 id="webpack-2"><a href="#webpack-2" aria-hidden="true" class="header-anchor">#</a> webpack</h2> <h2 id="babel"><a href="#babel" aria-hidden="true" class="header-anchor">#</a> babel</h2> <p>https://juejin.im/post/5d0373a95188251e1b5ebb6c</p> <h3 id="performance"><a href="#performance" aria-hidden="true" class="header-anchor">#</a> performance</h3> <p>js：压缩，拆分，tree-shaking，按需，gzip
css：压缩，按需，gzip
img：cdn，http cache
http：gzip dns-prefetch perload prefetch
svg: 压缩合并</p> <h3 id="document-的-load-事件和-domcontentloaded-事件之间的区别"><a href="#document-的-load-事件和-domcontentloaded-事件之间的区别" aria-hidden="true" class="header-anchor">#</a> document 的 load 事件和 DOMContentLoaded 事件之间的区别</h3> <p>当初始的 HTML 文档被完全加载和解析完成之后，DOMContentLoaded 事件被触发，而无需等待样式表、图像和子框架的完成加载。
load 事件仅在 DOM 和所有相关资源全部完成加载后才会触发。</p> <h3 id="sort-原理"><a href="#sort-原理" aria-hidden="true" class="header-anchor">#</a> sort 原理</h3> <p>chrome 当数组长度小于等于 10 的时候，采用插入排序，大于 10 的时候，采用快排。
其它有用归并排序的</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/xieliuduo/edit/master/docs/interview/remember/js.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">7/31/2019, 7:49:28 AM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/awesome-bookmarks/assets/js/app.6d21f2b1.js" defer></script><script src="/awesome-bookmarks/assets/js/2.d71abe12.js" defer></script><script src="/awesome-bookmarks/assets/js/63.934cac4a.js" defer></script>
  </body>
</html>
